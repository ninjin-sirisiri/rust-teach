use super::Lesson;

pub fn get_lesson() -> Lesson {
    Lesson {
        title: "Rustとは？".to_string(),
        content: "Rustは、安全性、スピード、並行性の3つに焦点を当てたシステムプログラミング言語です。

### 特徴の比較
昔ながらの言語や他のモダンな言語と比較して、Rustがどこに位置するのか見てみましょう。

```text
       [制御のしやすさ(Control)]
              ^
              |
      C/C++   |   Rust (理想的なバランス)
      (High)  |  (High)
              |
<-------------+-------------> [安全性(Safety)]
              |
  Assembly    |   Python/Ruby/Java
   (Low)      |      (High)
              |
```
- **C/C++**: メモリやハードウェアを細かく制御できますが、安全性の責任はプログラマにあります。
- **Python/Java**: 安全で書きやすいですが、ガベージコレクション(GC)による実行時のオーバーヘッドがあります。
- **Rust**: **「所有権」**という仕組みで、GCなしで安全性を担保します。

**主な特徴:**
1. **メモリ安全性:** メモリリークやダングリングポインタ（無効なメモリ参照）をコンパイル時に防ぎます。
2. **ゼロコスト抽象化:** 高レベルな書き方をしても、手書きの低レベルコードと同等の速度で動作します。
3. **恐れを知らぬ並行性:** データ競合（Data Race）をコンパイル時に検出するため、並列処理のバグに悩まされにくいです。

**Concept: ゼロコスト抽象化とは？**
「使わないものにコストを払わず、使うものはそれ以上に最適化できない」という設計思想です。
例えば、Rustのイテレータ（`.map`, `.filter`）は、最終的に最適化されたループ処理と同じ機械語に変換されます。".to_string(),
        code_examples: vec![
            "// C++のような「手動メモリ管理」のコード（イメージ）
// int* p = malloc(sizeof(int));
// *p = 10;
// free(p); // 忘れるとメモリリーク！

// Rustの場合：スコープを抜けると自動で解放される
fn main() {
    let x = Box::new(10); // ヒープに確保
    println!(\"x = {}\", x);
} // ここで自動的にメモリが解放される（GCは走らない！）".to_string()
        ],
        learning_points: vec![
            "Rustは「安全性」と「速度」を両立した言語です。".to_string(),
            "ガベージコレクション(GC)なしでメモリ安全性を保証します。".to_string(),
            "システムプログラミングからWebAssemblyまで幅広く使われています。".to_string(),
        ],
    }
}
